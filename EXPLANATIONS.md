## OAuth 2.0 with PKCE Flow:

How to generate a secret? 

```python
python3 -c "import secrets; print(f'SECRET_KEY={secrets.token_urlsafe(32)}')"
```




## Code explanations

#### StateStore 
`StateStore` class is a **thread-safe**, **temporary in-memory storage** for "states" with associated metadata (a **code verifier** + **timestamp**)
The `StateStore` saves the `code_verifier` temporarily (along with the `state`) so that later, **when the redirect comes back**, our app **can retrieve it and complete the token exchange**.

`code_verifier` is a **random**, **high-entropy string** (like a long random password) **generated by our app** before redirecting **the user to the identity provider** (e.g., Google, Auth0).
From the code verifier, **our app derives a code challenge** (usually by applying SHA-256 and Base64 URL encoding).

**Race condition** occurs when **multiple threads or processes read** and **write the same variable** i.e. they have access to some shared data and they try to change it at the same time. In such a scenario threads are “racing” each other to access/change the data.

```python
class StateStore:
    def __init__(self):
        self._store = {}
        self._lock = threading.Lock()

# self._store: A dictionary that holds state entries.
# self._lock: A threading lock to ensure thread safety (so multiple threads don’t modify the store at the same time).
        
    def set_state(self, state: str, code_verifier: str):
        with self._lock:
            self._store[state] = {
                'code_verifier': code_verifier,
                'timestamp': datetime.utcnow()
            }
            # Clean up old entries (older than 10 minutes)
            cutoff = datetime.utcnow() - timedelta(minutes=10)
            self._store = {k: v for k, v in self._store.items() 
                          if v['timestamp'] > cutoff}
            logger.debug(f"State store now has {len(self._store)} entries")
    
    def get_and_remove_state(self, state: str) -> str:
        with self._lock:
            data = self._store.pop(state, None)
            if data:
                logger.debug(f"Retrieved state from backup store")
                return data['code_verifier']
            logger.debug(f"State not found in backup store")
            return None
```

- Race Condition, Deadlock and Threat Block

### Code verifier
`code verifier` is only known to the client (our app), and we’ll need it later to finish the flow:

- **Step 1** – Start Auth Request
  - Our app generates a `state` and a `code verifier`.
  - It stores the `code verifier` temporarily (in memory, DB, or a structure like our StateStore).
  - It derives a `code challenge` and sends it to the **identity provider** with the **state**.

``` shell
/authorize?client_id=...&state=XYZ&code_challenge=HASH(verifier)&...
```

- **Step 2 – User Authenticates**
  - The user logs in at the provider.
  - The provider redirects back to our app with the `state` and an `authorization code`.

``` shell
/callback?state=XYZ&code=AUTH_CODE
```

- **Step 3 – Token Exchange**
  - Our app **retrieves the stored code verifier** for that state.
  - It sends the `AUTH_CODE` + `code_verifier` to the provider’s token endpoint.

``` shell
POST /token
{
  "code": "AUTH_CODE",
  "code_verifier": "ORIGINAL_RANDOM_STRING"
}
```
- The provider **recomputes the hash** from **our verifier** and checks it against the `code_challenge` from Step 1.
- If they match → we’re the legitimate client → we get tokens (access/refresh).


## Bibliography
- https://developer.reachfive.com/docs/flows/authorization-code-pkce.html
- https://docs.abblix.com/docs/openid-connect-flows-explained-simply-from-implicit-flows-to-authorization-code-flows-with-pkce-and-bff
